const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const sharp = require('sharp');
const { authenticateToken, requireEditor } = require('../middleware/auth');
const { uploadToCloudinary, deleteFromCloudinary } = require('../utils/cloudinary');

const router = express.Router();

// Thumbnails are now generated by Cloudinary via URL transformations
// No local thumbnail generation needed


  // Ensure upload directories exist
const createUploadDirs = () => {
  // Use absolute paths based on server directory
  const serverBasePath = path.join(__dirname, '..');
  const dirs = [
    path.join(serverBasePath, 'uploads'),
    path.join(serverBasePath, 'uploads/gallery'),
    path.join(serverBasePath, 'uploads/items'),
    // Thumbnails directory removed - using Cloudinary transformations instead
    path.join(serverBasePath, 'uploads/logo'),
    path.join(serverBasePath, 'uploads/about')
  ];
  
  dirs.forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
      console.log(`ðŸ“ Created directory: ${dir}`);
    }
  });
};

createUploadDirs();

// Configure multer for different file types
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    let uploadPath = path.join(__dirname, '../uploads/');
    
    console.log('ðŸ“ Multer file fieldname:', file.fieldname);
    
    if (file.fieldname === 'cocktail') {
      uploadPath = path.join(uploadPath, 'cocktails/');
    } else if (file.fieldname === 'gallery') {
      uploadPath = path.join(uploadPath, 'gallery/');
    } else if (file.fieldname === 'logo') {
      uploadPath = path.join(uploadPath, 'logo/');
    } else if (file.fieldname === 'aboutImage') {
      uploadPath = path.join(uploadPath, 'about/');
      console.log('âœ… About image detected - saving to about folder');
    } else {
      uploadPath = path.join(uploadPath, 'gallery/');
      console.log('âš ï¸  Unknown fieldname, defaulting to gallery folder');
    }
    
    console.log('ðŸ“ Multer destination path:', uploadPath);
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    // Generate unique filename with timestamp
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const ext = path.extname(file.originalname);
    const name = path.basename(file.originalname, ext);
    const filename = `${name}-${uniqueSuffix}${ext}`;
    console.log('ðŸ“ Generated filename:', filename);
    cb(null, filename);
  }
});

// File filter function
const fileFilter = (req, file, cb) => {
  const allowedImageTypes = /jpeg|jpg|png|gif|webp|svg/;
  const allowedVideoTypes = /mp4|mov|avi|webm/;
  
  // Log file information for debugging
  const ext = path.extname(file.originalname).toLowerCase();
  console.log('ðŸ” FileFilter - File info:', {
    fieldname: file.fieldname,
    originalname: file.originalname,
    mimetype: file.mimetype,
    extension: ext,
    isLogo: file.fieldname === 'logo'
  });
  
  if (file.fieldname === 'cocktail') {
    // For cocktail videos
    const ext = path.extname(file.originalname).toLowerCase();
    if (allowedVideoTypes.test(ext)) {
      console.log('âœ… FileFilter - Cocktail video accepted');
      cb(null, true);
    } else {
      console.log('âŒ FileFilter - Cocktail video rejected:', ext);
      cb(new Error('Only video files are allowed for cocktails'), false);
    }
  } else if (file.fieldname === 'logo' || file.fieldname === 'aboutImage') {
    // For logo images and about images (SVG preferred for logos)
    const ext = path.extname(file.originalname).toLowerCase();
    
    // Define allowed extensions explicitly
    const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'];
    
    // Check if extension is in the allowed list
    if (allowedExtensions.includes(ext)) {
      console.log('âœ… FileFilter - Logo/About image accepted:', { ext, mimetype: file.mimetype, fieldname: file.fieldname });
      cb(null, true);
    } else {
      console.log('âŒ FileFilter - Logo/About image rejected:', { 
        ext, 
        mimetype: file.mimetype, 
        fieldname: file.fieldname,
        originalname: file.originalname
      });
      cb(new Error(`Only image files (SVG preferred) are allowed. Received extension: ${ext || 'none'}, MIME type: ${file.mimetype || 'unknown'}`), false);
    }
  } else {
    // For gallery images (default)
    const ext = path.extname(file.originalname).toLowerCase();
    if (allowedImageTypes.test(ext)) {
      console.log('âœ… FileFilter - Gallery image accepted');
      cb(null, true);
    } else {
      console.log('âŒ FileFilter - Gallery image rejected:', ext);
      cb(new Error('Only image files are allowed for gallery'), false);
    }
  }
};

// Configure multer
const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    files: 10 // Max 10 files at once
  }
});

// @route   POST /api/upload/cocktail
// @desc    Upload cocktail video
// @access  Private (Editor)
router.post('/cocktail', [
  authenticateToken,
  requireEditor,
  upload.single('cocktail')
], async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const fileInfo = {
      filename: req.file.filename,
      originalName: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      path: `/uploads/items/${req.file.filename}`
    };

    res.json({
      message: 'Cocktail video uploaded successfully',
      file: fileInfo
    });
  } catch (error) {
    console.error('Cocktail upload error:', error);
    res.status(500).json({ message: 'Upload failed' });
  }
});

// @route   POST /api/upload/gallery
// @desc    Upload gallery image (single file, sequential numbering)
// @access  Private (Editor)
router.post('/gallery', [
  authenticateToken,
  requireEditor,
  upload.single('gallery')
], async (req, res) => {
  try {
    console.log('ðŸ“¤ Gallery upload request received');
    console.log('ðŸ” User authenticated:', req.user.email);
    
    if (!req.file) {
      console.log('âŒ No file in request');
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;
      console.log(`   Processing: ${file.originalname} -> ${file.filename}`);
      console.log(`      Size: ${file.size} bytes`);
      console.log(`      MIME: ${file.mimetype}`);
    console.log(`      Temp path: ${file.path}`);

    // Import Gallery model and Cloudinary
    const Gallery = require('../models/Gallery');
    const { cloudinary } = require('../utils/cloudinary');

    // 1. Determine next photo number using photoNumber field (sequential: 1, 2, 3, etc.)
    const lastPhoto = await Gallery.findOne({ category: 'gallery', photoNumber: { $exists: true } })
      .sort({ photoNumber: -1 })
      .select('photoNumber')
      .lean();
    
    const nextNumber = lastPhoto && lastPhoto.photoNumber ? lastPhoto.photoNumber + 1 : 1;
    console.log(`   ðŸ“¸ Next photo number: ${nextNumber}`);

    // 2. Construct public_id with full path (no folder parameter)
    // Public ID format: "echo-catering/gallery/{number}_gallery"
    const publicId = `echo-catering/gallery/${nextNumber}_gallery`;
    console.log(`   ðŸ“¸ Public ID: ${publicId}`);

    // 3. Upload to Cloudinary (upload first, cleanup after)
    console.log(`   â˜ï¸  Uploading to Cloudinary...`);
    // Verify temp file exists on disk before uploading
    try {
      const stats = fs.statSync(file.path);
      console.log(`   âœ… Temp file exists (${stats.size} bytes)`);
    } catch (statErr) {
      console.error(`   âŒ Temp file missing before upload: ${file.path}`);
      return res.status(500).json({ message: 'Uploaded file not found on disk' });
    }
    const cloudinaryResult = await cloudinary.uploader.upload(file.path, {
      public_id: publicId, // Full path: echo-catering/gallery/{number}_gallery
      resource_type: 'image',
      overwrite: false, // Never overwrite - each photo gets unique number
    });

    // 4. Confirm Cloudinary returns secure_url
    if (!cloudinaryResult || !cloudinaryResult.secure_url) {
      throw new Error('Cloudinary upload failed - no secure_url returned');
    }

    console.log(`   âœ… Uploaded to Cloudinary: ${cloudinaryResult.secure_url}`);
    console.log(`   ðŸ“Œ Public ID: ${cloudinaryResult.public_id}`);

    // 5. Generate thumbnail URL (Cloudinary transformation - no local file)
    const thumbnailUrl = cloudinary.url(cloudinaryResult.public_id, {
      width: 200,
      height: 200,
      crop: 'fill',
      quality: 'auto',
      fetch_format: 'auto'
    });

    console.log(`   ðŸ–¼ï¸  Thumbnail URL: ${thumbnailUrl}`);

    // 6. Save photoNumber, cloudinaryPublicId, and cloudinaryUrl in database
    let galleryRecord = null;
    try {
      galleryRecord = await Gallery.create({
        filename: `${nextNumber}.jpg`, // Virtual filename for compatibility
        originalName: file.originalname,
        title: file.originalname.replace(/\.[^/.]+$/, '').replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
        category: 'gallery',
        photoNumber: nextNumber, // Sequential photo number
        order: nextNumber,
        isActive: true,
        featured: false,
        fileSize: file.size,
        mimeType: file.mimetype,
        cloudinaryUrl: cloudinaryResult.secure_url,
        cloudinaryPublicId: cloudinaryResult.public_id,
        thumbnailUrl: thumbnailUrl,
        dimensions: {
          width: cloudinaryResult.width,
          height: cloudinaryResult.height
        }
      });
    } catch (dbErr) {
      console.error('   âŒ Failed to create gallery DB record:', dbErr.message);
      // Attempt to avoid orphan temp file
      try {
        if (fs.existsSync(file.path)) {
          fs.unlinkSync(file.path);
          console.log(`   ðŸ—‘ï¸  Deleted temp file after DB error: ${file.path}`);
        }
      } catch (cleanupErr) {
        console.warn(`   âš ï¸  Temp file cleanup failed after DB error: ${cleanupErr.message}`);
      }
      return res.status(500).json({ message: 'Database save failed after Cloudinary upload' });
    }

    console.log(`   âœ… Database record created: ${galleryRecord._id}`);
    console.log(`   ðŸ“¸ Photo number: ${galleryRecord.photoNumber}`);
    console.log(`   â˜ï¸  Cloudinary URL: ${galleryRecord.cloudinaryUrl}`);
    console.log(`   ðŸ“Œ Cloudinary Public ID: ${galleryRecord.cloudinaryPublicId}`);

    // 7. Delete local temp file after successful upload and DB save (safe cleanup)
    try {
      if (fs.existsSync(file.path)) {
        fs.unlinkSync(file.path);
        console.log(`   ðŸ—‘ï¸  Deleted temp file: ${file.path}`);
      } else {
        console.log(`   â„¹ï¸  Temp file already removed: ${file.path}`);
      }
    } catch (cleanupErr) {
      console.warn(`   âš ï¸  Failed to delete temp file: ${cleanupErr.message}`);
    }

    // 6. Return response for frontend (compatible with existing UI)
    res.json({
      success: true,
      message: 'Image uploaded successfully',
      files: [{
        cloudinaryUrl: galleryRecord.cloudinaryUrl,
        publicId: galleryRecord.cloudinaryPublicId,
        thumbnailUrl: thumbnailUrl,
        filename: galleryRecord.filename,
        originalName: galleryRecord.originalName
      }]
    });
  } catch (error) {
    console.error('âŒ Gallery upload error:', error);
    // Attempt safe cleanup if multer saved the file and it still exists
    try {
      if (req.file && req.file.path && fs.existsSync(req.file.path)) {
        fs.unlinkSync(req.file.path);
        console.log(`   ðŸ—‘ï¸  Deleted temp file after error: ${req.file.path}`);
      }
    } catch (cleanupErr) {
      console.warn(`   âš ï¸  Failed to cleanup temp file after error: ${cleanupErr.message}`);
    }
    res.status(500).json({ message: 'Upload failed' });
  }
});

// @route   DELETE /api/upload/gallery/:filename
// @desc    Delete gallery image from Cloudinary and database (Cloudinary-only storage)
// @access  Private (Editor)
router.delete('/gallery/:filename', [
  authenticateToken,
  requireEditor
], async (req, res) => {
  try {
    const filename = req.params.filename;
    if (!filename) {
      return res.status(400).json({ message: 'Filename is required' });
    }

    // Load Gallery model and find record by filename
    const Gallery = require('../models/Gallery');
    const { cloudinary } = require('../utils/cloudinary');
    const record = await Gallery.findOne({ filename });

    if (!record) {
      return res.status(404).json({ message: 'Gallery record not found' });
    }

    // 1. Delete from Cloudinary using cloudinaryPublicId
    if (record.cloudinaryPublicId) {
      try {
        console.log(`â˜ï¸  Deleting from Cloudinary: ${record.cloudinaryPublicId}`);
        await cloudinary.uploader.destroy(record.cloudinaryPublicId, {
          resource_type: 'image'
        });
        console.log('âœ… Deleted from Cloudinary');
      } catch (cloudinaryError) {
        console.error('âŒ Cloudinary delete failed:', cloudinaryError.message);
        // Continue with DB deletion even if Cloudinary delete fails
      }
    }

    // 2. Delete from database
    await Gallery.findByIdAndDelete(record._id);
    console.log(`âœ… Deleted Gallery record: ${record._id}`);

    // 3. Return success to frontend
    return res.json({ success: true, message: 'Image deleted successfully' });
  } catch (error) {
    console.error('âŒ Gallery file delete error:', error);
    res.status(500).json({ message: 'File delete failed' });
  }
});

// @route   POST /api/upload/about-image
// @desc    Upload about page image and optionally copy to section file
// @access  Private (Editor)
router.post('/about-image', [
  authenticateToken,
  requireEditor,
  upload.single('aboutImage')
], async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    // Check if it's an image file
    const allowedImageTypes = /jpeg|jpg|png|gif|webp/;
    if (!allowedImageTypes.test(path.extname(req.file.originalname).toLowerCase())) {
      return res.status(400).json({ message: 'Only image files are allowed for about images' });
    }

    // Use the actual file path from multer (req.file.path)
    // This ensures we use the file where multer actually saved it
    let actualFilePath = req.file.path;
    console.log(`   ðŸ“ File was saved to: ${actualFilePath}`);
    
    // Verify file exists at the actual location
    if (!fs.existsSync(actualFilePath)) {
      console.error(`   âŒ File not found at: ${actualFilePath}`);
      return res.status(500).json({ message: 'Uploaded file not found' });
    }
    
    // Check if file was saved to gallery instead of about (this shouldn't happen, but let's handle it)
    if (actualFilePath.includes('uploads/gallery') && !actualFilePath.includes('uploads/about')) {
      console.warn(`   âš ï¸  File was saved to gallery instead of about! Moving it...`);
      // Move file to about folder
      const aboutDir = path.join(__dirname, '../uploads/about');
      if (!fs.existsSync(aboutDir)) {
        fs.mkdirSync(aboutDir, { recursive: true });
      }
      const correctAboutPath = path.join(aboutDir, req.file.filename);
      fs.renameSync(actualFilePath, correctAboutPath);
      console.log(`   âœ… Moved file to: ${correctAboutPath}`);
      // Update the path to use
      actualFilePath = correctAboutPath;
    }

    // Check if sectionNumber is provided in query or body
    // Note: With multer, non-file fields are in req.body
    let sectionNumber = req.query.sectionNumber || req.body?.sectionNumber;
    
    // Normalize section number: extract numeric part (handles "1", "section-1", "section1", etc.)
    if (sectionNumber) {
      const numericMatch = String(sectionNumber).match(/\d+/);
      sectionNumber = numericMatch ? numericMatch[0] : sectionNumber;
      console.log('ðŸ“‹ Section number from request (normalized):', sectionNumber);
    } else {
    console.log('ðŸ“‹ Section number from request:', sectionNumber);
    }
    console.log('ðŸ“‹ Request body:', req.body);
    
    // If section number provided, save directly to section file and delete temporary file
    if (sectionNumber) {
      const sectionFileName = `section${sectionNumber}.jpg`;
      const sectionFilePath = path.join(__dirname, '../uploads/about', sectionFileName);
      
      // Ensure about directory exists
      const aboutDir = path.dirname(sectionFilePath);
      if (!fs.existsSync(aboutDir)) {
        fs.mkdirSync(aboutDir, { recursive: true });
      }
      
      try {
        // Overwrite existing file if it exists
        if (fs.existsSync(sectionFilePath)) {
          fs.unlinkSync(sectionFilePath);
          console.log(`   ðŸ”„ Overwriting existing ${sectionFileName}`);
        }

        // Get file extension from original file
        const ext = path.extname(req.file.originalname).toLowerCase();

        // Convert to JPEG format using sharp (or copy if already JPEG)
        // Use actualFilePath which is the real location of the uploaded file
        if (ext === '.jpg' || ext === '.jpeg') {
          // Already JPEG, just copy
          fs.copyFileSync(actualFilePath, sectionFilePath);
        } else {
          // Convert to JPEG using sharp
          await sharp(actualFilePath)
            .jpeg({ 
              quality: 90,
              mozjpeg: true 
            })
            .toFile(sectionFilePath);
        }

        // Delete the temporary uploaded file since we have the section file
        try {
          if (fs.existsSync(actualFilePath)) {
            fs.unlinkSync(actualFilePath);
            console.log(`   ðŸ—‘ï¸  Deleted temporary file: ${req.file.filename}`);
          }
        } catch (deleteError) {
          console.warn(`   âš ï¸  Could not delete temporary file:`, deleteError);
        }

        console.log(`   âœ… Saved directly to ${sectionFileName}`);
        
        const localPath = `/uploads/about/${sectionFileName}`;
        const fileInfo = {
          filename: sectionFileName,
          originalName: req.file.originalname,
          mimetype: req.file.mimetype,
          size: req.file.size,
          path: localPath,
          localPath: localPath,
          sectionPath: localPath,
          cloudinaryUrl: null
        };

        // Upload to Cloudinary (non-blocking - if it fails, still return success with local path)
        try {
          console.log(`   â˜ï¸  Uploading section ${sectionNumber} image to Cloudinary...`);
          // Use consistent publicId for section to overwrite existing section images (same format as logo)
          const publicId = `${sectionNumber}_about`; // e.g., "1_about", "2_about" -> echo-catering/about/1_about
          
          const cloudinaryResult = await uploadToCloudinary(sectionFilePath, {
            folder: 'echo-catering/about',
            resourceType: 'image',
            publicId: publicId, // Consistent publicId ensures overwrite (like logo)
            overwrite: true, // Explicitly enable overwrite like logo upload
          });

          console.log(`   âœ… Uploaded to Cloudinary: ${cloudinaryResult.url}`);
          fileInfo.cloudinaryUrl = cloudinaryResult.url;

          // Update or create Content record with Cloudinary URL
          const Content = require('../models/Content');
          let content = await Content.findOne({
            page: 'about',
            section: `section${sectionNumber}`,
            type: 'image'
          });

          if (content) {
            // Update existing content
            content.cloudinaryUrl = cloudinaryResult.url;
            content.cloudinaryPublicId = cloudinaryResult.publicId;
            // Clear local path - Cloudinary is the source of truth
            if (content.metadata) {
              content.metadata.delete('image');
            }
            await content.save();
            console.log(`   âœ… Content record updated with Cloudinary URL for section ${sectionNumber}`);
          } else {
            // Create new content
            content = new Content({
              page: 'about',
              section: `section${sectionNumber}`,
              type: 'image',
              cloudinaryUrl: cloudinaryResult.url,
              cloudinaryPublicId: cloudinaryResult.publicId,
              isActive: true
            });
            await content.save();
            console.log(`   âœ… New Content record created with Cloudinary URL for section ${sectionNumber}`);
          }

          // Delete local file after successful Cloudinary upload and DB update
          try {
            if (fs.existsSync(sectionFilePath)) {
              await fs.promises.unlink(sectionFilePath);
              console.log(`   ðŸ—‘ï¸  Deleted local file after Cloudinary upload: ${sectionFileName}`);
            }
          } catch (deleteError) {
            console.warn(`   âš ï¸  Could not delete local file:`, deleteError);
          }
        } catch (cloudinaryError) {
          // Log error but don't fail the upload
          console.error(`   âš ï¸  Cloudinary upload failed for section ${sectionNumber} (non-fatal):`, cloudinaryError.message);
          console.error(`   Image saved locally, but Cloudinary upload failed. Local path will be used.`);
          
          // Still update Content record with local path only (if it doesn't exist)
          const Content = require('../models/Content');
          let content = await Content.findOne({
            page: 'about',
            section: `section${sectionNumber}`,
            type: 'image'
          });

          if (!content) {
            content = new Content({
              page: 'about',
              section: `section${sectionNumber}`,
              type: 'image',
              metadata: new Map([['image', localPath]]),
              isActive: true
            });
            await content.save();
            console.log(`   âœ… Content record created (local path only) for section ${sectionNumber}`);
          }
        }

        console.log('âœ… About image uploaded and saved to section:', fileInfo.sectionPath);

        return res.json({
          message: 'About image uploaded and saved to section file successfully',
          file: fileInfo
        });
      } catch (copyError) {
        console.error(`   âš ï¸  Error saving to section file:`, copyError);
        // Continue with regular response even if copy fails
      }
    }

    // Ensure the file is in the about folder (if it wasn't moved earlier)
    if (actualFilePath.includes('uploads/gallery') && !actualFilePath.includes('uploads/about')) {
      const aboutDir = path.join(__dirname, '../uploads/about');
      if (!fs.existsSync(aboutDir)) {
        fs.mkdirSync(aboutDir, { recursive: true });
      }
      const correctAboutPath = path.join(aboutDir, req.file.filename);
      fs.renameSync(actualFilePath, correctAboutPath);
      actualFilePath = correctAboutPath;
      console.log(`   âœ… Moved file to about folder: ${correctAboutPath}`);
    }

    const localPath = `/uploads/about/${req.file.filename}`;
    const fileInfo = {
      filename: req.file.filename,
      originalName: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      path: localPath,
      localPath: localPath,
      cloudinaryUrl: null
    };

    // Upload to Cloudinary (non-blocking - if it fails, still return success with local path)
    try {
      console.log('â˜ï¸  Uploading about image to Cloudinary...');
      // Use filename-based publicId to overwrite existing files with same name
      const baseName = req.file.filename.replace(/-\d{13}-\d+\./, '.').replace(/\.[^/.]+$/, '');
      const publicId = baseName; // Use base filename as publicId for overwriting
      
      const cloudinaryResult = await uploadToCloudinary(actualFilePath, {
        folder: 'echo-catering/about',
        resourceType: 'image',
        publicId: publicId, // Consistent publicId based on filename ensures overwrite
      });

      console.log('âœ… About image uploaded to Cloudinary:', cloudinaryResult.url);
      fileInfo.cloudinaryUrl = cloudinaryResult.url;

      // Update or create Content record with Cloudinary URL
      const Content = require('../models/Content');
      let content = await Content.findOne({
        page: 'about',
        section: 'main',
        type: 'image'
      });

      if (content) {
        // Update existing content
        content.cloudinaryUrl = cloudinaryResult.url;
        content.cloudinaryPublicId = cloudinaryResult.publicId;
        // Clear local path - Cloudinary is the source of truth
        if (content.metadata) {
          content.metadata.delete('image');
        }
        await content.save();
        console.log('âœ… Content record updated with Cloudinary URL');
      } else {
        // Create new content
        content = new Content({
          page: 'about',
          section: 'main',
          type: 'image',
          cloudinaryUrl: cloudinaryResult.url,
          cloudinaryPublicId: cloudinaryResult.publicId,
          isActive: true
        });
        await content.save();
        console.log('âœ… New Content record created with Cloudinary URL');
      }

      // Delete local file after successful Cloudinary upload and DB update
      try {
        if (fs.existsSync(actualFilePath)) {
          await fs.promises.unlink(actualFilePath);
          console.log(`   ðŸ—‘ï¸  Deleted local file after Cloudinary upload: ${req.file.filename}`);
        }
      } catch (deleteError) {
        console.warn(`   âš ï¸  Could not delete local file:`, deleteError);
      }
    } catch (cloudinaryError) {
      // Log error but don't fail the upload
      console.error('âš ï¸  Cloudinary upload failed (non-fatal):', cloudinaryError.message);
      console.error('   Image saved locally, but Cloudinary upload failed. Local path will be used.');
      
      // Still update Content record with local path only (if it doesn't exist)
      const Content = require('../models/Content');
      let content = await Content.findOne({
        page: 'about',
        section: 'main',
        type: 'image'
      });

      if (!content) {
        content = new Content({
          page: 'about',
          section: 'main',
          type: 'image',
          metadata: new Map([['image', localPath]]),
          isActive: true
        });
        await content.save();
        console.log('âœ… Content record created (local path only)');
      }
    }

    console.log('âœ… About image uploaded:', fileInfo.path);
    console.log(`   ðŸ“ Saved to: ${actualFilePath}`);

    res.json({
      message: 'About image uploaded successfully',
      file: fileInfo
    });
  } catch (error) {
    console.error('About image upload error:', error);
    res.status(500).json({ message: 'Upload failed' });
  }
});

// @route   POST /api/upload/copy-to-section
// @desc    Copy uploaded image to about folder with section naming
// @access  Private (Editor)
router.post('/copy-to-section', [
  authenticateToken,
  requireEditor
], async (req, res) => {
  try {
    let { sourcePath, sectionNumber } = req.body;
    
    if (!sourcePath || !sectionNumber) {
      return res.status(400).json({ message: 'sourcePath and sectionNumber are required' });
    }
    
    // Normalize section number: extract numeric part (handles "1", "section-1", "section1", etc.)
    const numericMatch = String(sectionNumber).match(/\d+/);
    sectionNumber = numericMatch ? numericMatch[0] : sectionNumber;
    console.log('ðŸ“‹ Section number (normalized):', sectionNumber);

    const aboutPath = path.join(__dirname, '../uploads/about');
    if (!fs.existsSync(aboutPath)) {
      fs.mkdirSync(aboutPath, { recursive: true });
    }

    const sectionFileName = `section${sectionNumber}.jpg`;
    const aboutFilePath = path.join(aboutPath, sectionFileName);
    
    // Get source file path - handle both /uploads/about/filename and full paths
    let sourceFilePath;
    if (sourcePath.startsWith('/uploads/')) {
      // Remove /uploads prefix and construct full path
      const relativePath = sourcePath.replace('/uploads/', '');
      sourceFilePath = path.join(__dirname, '../uploads', relativePath);
    } else {
      sourceFilePath = sourcePath;
    }

    if (!fs.existsSync(sourceFilePath)) {
      return res.status(404).json({ message: 'Source file not found' });
    }

    try {
      // Overwrite existing file if it exists
      if (fs.existsSync(aboutFilePath)) {
        fs.unlinkSync(aboutFilePath);
        console.log(`   ðŸ”„ Overwriting existing ${sectionFileName}`);
      }

      // Get file extension
      const ext = path.extname(sourceFilePath).toLowerCase();

      // Convert to JPEG format using sharp
      if (ext === '.jpg' || ext === '.jpeg') {
        // Already JPEG, just copy
        fs.copyFileSync(sourceFilePath, aboutFilePath);
      } else {
        // Convert to JPEG using sharp
        await sharp(sourceFilePath)
          .jpeg({ 
            quality: 90,
            mozjpeg: true 
          })
          .toFile(aboutFilePath);
      }

      console.log(`   âœ… Copied/Converted to server/uploads/about/${sectionFileName}`);

      const localPath = `/uploads/about/${sectionFileName}`;
      const responseData = {
        message: 'Image copied to section file successfully',
        path: localPath,
        localPath: localPath,
        cloudinaryUrl: null
      };

      // Upload to Cloudinary (non-blocking - if it fails, still return success with local path)
      try {
        console.log(`   â˜ï¸  Uploading section ${sectionNumber} image to Cloudinary...`);
        // Use consistent publicId for section to overwrite existing section images (same format as logo)
        const publicId = `${sectionNumber}_about`; // e.g., "1_about", "2_about" -> echo-catering/about/1_about
        
        const cloudinaryResult = await uploadToCloudinary(aboutFilePath, {
          folder: 'echo-catering/about',
          resourceType: 'image',
          publicId: publicId, // Consistent publicId ensures overwrite (like logo)
          overwrite: true, // Explicitly enable overwrite like logo upload
        });

        console.log(`   âœ… Uploaded to Cloudinary: ${cloudinaryResult.url}`);
        responseData.cloudinaryUrl = cloudinaryResult.url;

        // Update or create Content record with Cloudinary URL
        const Content = require('../models/Content');
        let content = await Content.findOne({
          page: 'about',
          section: `section${sectionNumber}`,
          type: 'image'
        });

        if (content) {
          // Update existing content
          content.cloudinaryUrl = cloudinaryResult.url;
          content.cloudinaryPublicId = cloudinaryResult.publicId;
          // Clear local path - Cloudinary is the source of truth
          if (content.metadata) {
            content.metadata.delete('image');
          }
          await content.save();
          console.log(`   âœ… Content record updated with Cloudinary URL for section ${sectionNumber}`);
        } else {
          // Create new content
          content = new Content({
            page: 'about',
            section: `section${sectionNumber}`,
            type: 'image',
            cloudinaryUrl: cloudinaryResult.url,
            cloudinaryPublicId: cloudinaryResult.publicId,
            isActive: true
          });
          await content.save();
          console.log(`   âœ… New Content record created with Cloudinary URL for section ${sectionNumber}`);
        }

        // Delete local file after successful Cloudinary upload and DB update
        try {
          if (fs.existsSync(aboutFilePath)) {
            await fs.promises.unlink(aboutFilePath);
            console.log(`   ðŸ—‘ï¸  Deleted local file after Cloudinary upload: ${sectionFileName}`);
          }
        } catch (deleteError) {
          console.warn(`   âš ï¸  Could not delete local file:`, deleteError);
        }
      } catch (cloudinaryError) {
        // Log error but don't fail the copy
        console.error(`   âš ï¸  Cloudinary upload failed for section ${sectionNumber} (non-fatal):`, cloudinaryError.message);
        console.error(`   Image copied locally, but Cloudinary upload failed. Local path will be used.`);
        
        // Still update Content record with local path only (if it doesn't exist)
        const Content = require('../models/Content');
        let content = await Content.findOne({
          page: 'about',
          section: `section${sectionNumber}`,
          type: 'image'
        });

        if (!content) {
          content = new Content({
            page: 'about',
            section: `section${sectionNumber}`,
            type: 'image',
            metadata: new Map([['image', localPath]]),
            isActive: true
          });
          await content.save();
          console.log(`   âœ… Content record created (local path only) for section ${sectionNumber}`);
        }
      }

      res.json(responseData);
    } catch (copyError) {
      console.error(`   âŒ Error copying to section file:`, copyError);
      res.status(500).json({ message: 'Failed to copy file' });
    }
  } catch (error) {
    console.error('Copy to section error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// @route   POST /api/upload/logo
// @desc    Upload logo image
// @access  Private (Editor)
router.post('/logo', [
  authenticateToken,
  requireEditor,
  (req, res, next) => {
    upload.single('logo')(req, res, (err) => {
      if (err) {
        console.error('âŒ Multer error in logo upload:', err.message);
        console.error('âŒ Error details:', {
          code: err.code,
          field: err.field,
          message: err.message
        });
        return res.status(400).json({ 
          message: err.message || 'File upload failed',
          error: 'FILE_FILTER_REJECTED'
        });
      }
      next();
    });
  }
], async (req, res) => {
  try {
    console.log('ðŸ“¥ Logo upload request received');
    
    if (!req.file) {
      console.log('âŒ No file in request');
      return res.status(400).json({ message: 'No file uploaded. Please select a file.' });
    }
    
    console.log('âœ… File received:', {
      originalname: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      filename: req.file.filename
    });

    // Check if it's an image file (SVG is preferred)
    const ext = path.extname(req.file.originalname).toLowerCase();
    const allowedImageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'];
    
    // Explicitly check for SVG first (preferred)
    if (ext !== '.svg' && !allowedImageExtensions.includes(ext)) {
      console.log('âŒ Route validation rejected file:', { ext, originalname: req.file.originalname });
      return res.status(400).json({ 
        message: `Only image files (SVG preferred) are allowed for logo. Received: ${ext}` 
      });
    }
    
    console.log('âœ… Route validation passed for:', ext);

    // Import Content model and Cloudinary SDK
    const Content = require('../models/Content');
    const { cloudinary } = require('../utils/cloudinary');

    console.log(`   ðŸ“ Temp file path: ${req.file.path}`);

    // 1. Upload to Cloudinary with publicId "logo" (overwrites existing)
    console.log('â˜ï¸  Uploading logo to Cloudinary...');
    const publicId = 'logo'; // Always use "logo" for overwriting
    // This creates: echo-catering/logo in Cloudinary
    
    const cloudinaryResult = await cloudinary.uploader.upload(req.file.path, {
      public_id: publicId,
      folder: 'echo-catering',
      resource_type: 'image',
      overwrite: true, // Enable overwrite - always replaces existing logo
    });

    if (!cloudinaryResult || !cloudinaryResult.secure_url) {
      throw new Error('Cloudinary upload failed - no secure_url returned');
    }

    console.log('âœ… Logo uploaded to Cloudinary:', cloudinaryResult.secure_url);
    console.log(`   ðŸ“Œ Public ID: ${cloudinaryResult.public_id}`);

    // 2. Update or create Content record with Cloudinary URL
    let logoContent = await Content.findOne({ 
      page: 'global', 
      section: 'header', 
      type: 'logo' 
    });

    if (logoContent) {
      // Update existing logo
      logoContent.cloudinaryUrl = cloudinaryResult.secure_url;
      logoContent.cloudinaryPublicId = cloudinaryResult.public_id;
      // Keep content field empty or remove local path reference
      await logoContent.save();
      console.log('âœ… Content record updated with Cloudinary URL');
    } else {
      // Create new logo content
      logoContent = new Content({
        page: 'global',
        section: 'header',
        type: 'logo',
        cloudinaryUrl: cloudinaryResult.secure_url,
        cloudinaryPublicId: cloudinaryResult.public_id,
        title: 'ECHO Catering Logo',
        altText: 'ECHO Catering Logo',
        order: 0,
        isActive: true
      });
      await logoContent.save();
      console.log('âœ… New Content record created with Cloudinary URL');
    }

    // 3. Delete local temp file
    fs.unlink(req.file.path, (err) => {
      if (err) {
        console.error(`   âš ï¸  Failed to delete temp file: ${err.message}`);
        } else {
        console.log(`   ðŸ—‘ï¸  Deleted temp file: ${req.file.path}`);
      }
    });

    // 4. Return response with Cloudinary URL
    res.json({
      success: true,
      message: 'Logo uploaded successfully',
      file: {
        cloudinaryUrl: cloudinaryResult.secure_url,
        publicId: cloudinaryResult.public_id,
        originalName: req.file.originalname
      }
    });
  } catch (error) {
    console.error('Logo upload error:', error);
    res.status(500).json({ message: 'Upload failed' });
  }
});

// @route   DELETE /api/upload/:type/:filename
// @desc    Delete uploaded file
// @access  Private (Editor)
router.delete('/:type/:filename', [authenticateToken, requireEditor], async (req, res) => {
  try {
    const { type, filename } = req.params;
    
    if (!['cocktails', 'gallery'].includes(type)) {
      return res.status(400).json({ message: 'Invalid file type' });
    }

    const filePath = path.join('server/uploads', type, filename);
    
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
      res.json({ message: 'File deleted successfully' });
    } else {
      res.status(404).json({ message: 'File not found' });
    }
  } catch (error) {
    console.error('Delete file error:', error);
    res.status(500).json({ message: 'Delete failed' });
  }
});

// @route   GET /api/upload/files/:type
// @desc    Get list of uploaded files by type
// @access  Private (Editor)
router.get('/files/:type', [authenticateToken, requireEditor], async (req, res) => {
  try {
    const { type } = req.params;
    
    if (!['cocktails', 'gallery'].includes(type)) {
      return res.status(400).json({ message: 'Invalid file type' });
    }

    const uploadPath = path.join('server/uploads', type);
    
    if (!fs.existsSync(uploadPath)) {
      return res.json([]);
    }

    const files = fs.readdirSync(uploadPath)
      .filter(file => {
        const ext = path.extname(file).toLowerCase();
        if (type === 'cocktails') {
          return /\.(mp4|mov|avi|webm)$/.test(ext);
        } else {
          return /\.(jpeg|jpg|png|gif|webp)$/.test(ext);
        }
      })
      .map(file => {
        const filePath = path.join(uploadPath, file);
        const stats = fs.statSync(filePath);
        return {
          filename: file,
          size: stats.size,
          created: stats.birthtime,
          path: `/uploads/${type}/${file}`
        };
      })
      .sort((a, b) => b.created - a.created);

    res.json(files);
  } catch (error) {
    console.error('Get files error:', error);
    res.status(500).json({ message: 'Failed to get files' });
  }
});

// Error handling middleware for multer
router.use((error, req, res, next) => {
  if (error instanceof multer.MulterError) {
    if (error.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ message: 'File too large. Maximum size is 50MB.' });
    }
    if (error.code === 'LIMIT_FILE_COUNT') {
      return res.status(400).json({ message: 'Too many files. Maximum is 10 files.' });
    }
    return res.status(400).json({ message: 'Upload error' });
  }
  
  if (error.message) {
    return res.status(400).json({ message: error.message });
  }
  
  next(error);
});

module.exports = router;


